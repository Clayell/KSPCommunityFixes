/*
The core of the issue is the asteroid/comet spawner passing a random int for the "id" argument of the ProtoVessel.CreatePartNode() method.
This id is affected to the part.flightId field, which must be unique game-wide and should have been generated by calling 
ShipConstruction.GetUniqueFlightID(). Failing to produce an unique flightId result in various issues, especially with mods as they often
rely on that id.

Note that by fixing this, we replace how the asteroid/comet "seed" is generated, which technically affect further calls to UnityEngine.Random(),
but this shouldn't have any effect on the actual randomness/distribution of the generated stuff.
*/

using System;
using System.Collections.Generic;
using HarmonyLib;
using KSP.UI.Screens;

namespace KSPCommunityFixes.BugFixes
{
    class StickySplashedFixer : BasePatch
    {
        protected override Version VersionMin => new Version(1, 8, 0);

        protected override void ApplyPatches(List<PatchInfo> patches)
        {
            patches.Add(new PatchInfo(
                PatchMethodType.Prefix,
                AccessTools.Method(typeof(Vessel), "updateSituation"),
                this));

            patches.Add(new PatchInfo(
                PatchMethodType.Prefix,
                AccessTools.Method(typeof(StageManager), "ActivateStage"),
                this));

            patches.Add(new PatchInfo(
                PatchMethodType.Postfix,
                AccessTools.Method(typeof(StageManager), "ActivateStage"),
                this));
        }

        static bool Vessel_updateSituation_Prefix(Vessel __instance)
        {
			bool flag;
            if (__instance.EVALadderVessel != __instance)
            {
                __instance.situation = __instance.evaController.LadderPart.vessel.situation;
                flag = true;
            }
            else
            {
                flag = false;
                if (__instance.situation == Vessel.Situations.PRELAUNCH)
                {
                    if (__instance.srfSpeed > (__instance.Splashed ? 1 : 2.5) && !__instance.precalc.isEasingGravity && !__instance.vesselSpawning)
                        __instance.situation = __instance.Splashed ? Vessel.Situations.SPLASHED : Vessel.Situations.LANDED;
                }
                else if (__instance.Landed)
                {
                    __instance.situation = Vessel.Situations.LANDED;
                }
                else if (__instance.Splashed)
                {
                    __instance.situation = Vessel.Situations.SPLASHED;
                }
                else
                {
                    if (__instance.staticPressurekPa > 0.0)
                    {
                        __instance.situation = Vessel.Situations.FLYING;
                    }
                    else if (__instance.orbit.eccentricity < 1.0 && __instance.orbit.ApR < __instance.mainBody.sphereOfInfluence)
                    {
                        if (__instance.orbit.PeA < (__instance.mainBody.atmosphere ? __instance.mainBody.atmosphereDepth : 0))
                        {
                            __instance.situation = Vessel.Situations.SUB_ORBITAL;
                        }
                        else
                        {
                            __instance.situation = Vessel.Situations.ORBITING;
                        }
                    }
                    else
                    {
                        __instance.situation = Vessel.Situations.ESCAPING;
                    }
                }
            }

            if (__instance.situation != __instance.lastSituation)
            {
                GameEvents.onVesselSituationChange.Fire(new GameEvents.HostedFromToAction<Vessel, Vessel.Situations>(__instance, __instance.lastSituation, __instance.situation));
                __instance.lastSituation = __instance.situation;
            }

            if (__instance.wasLadder != flag)
            {
                __instance.wasLadder = flag;
            }
            
            return false;
        }

        static List<Part> stagedPartList = new List<Part>();
        static HashSet<Vessel> vesselsToCheck = new HashSet<Vessel>();

        static void StageManager_ActivateStage_Prefix(StageManager __instance, out int __state)
        {
            stagedPartList.AddRange(FlightGlobals.ActiveVessel.Parts);
            __state = __instance._currentStage;
        }

        static void StageManager_ActivateStage_Postfix(StageManager __instance, int __state)
        {
            if (__instance._currentStage != __state)
            {
                for (int i = stagedPartList.Count; i-- > 0;)
                {
                    Vessel v = stagedPartList[i].vessel;
                    if (vesselsToCheck.Contains(v))
                        continue;

                    vesselsToCheck.Add(v);
                }

                foreach (Vessel v in vesselsToCheck)
                    v.UpdateLandedSplashed();
            }
            stagedPartList.Clear();
            vesselsToCheck.Clear();
        }
    }
}
